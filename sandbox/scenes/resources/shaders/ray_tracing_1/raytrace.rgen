#version 460
#extension GL_EXT_ray_tracing : require

#include "ray.glsl"
#include "random.glsl"
#include <RayTracing>

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;

layout(push_constant) uniform PushConstant {
    vec3 position;
    vec3 color;
    float intensity; 
    int sampleCount;
    int frame;
} constant;

layout(binding = 1, set = 1) uniform Camera {
    vec3 position;
    mat4 view;
    mat4 project;
} camera;

layout(location = 0) rayPayloadEXT HitPayload prd;

void main() {
    vec3 value = vec3(0);
    // 初始化随机种子
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, constant.frame);
    for (int i = 0; i < constant.sampleCount; i++) {
        // gl_LaunchIDEXT 包含被渲染像素的整数坐标位置，pixelPoint就是一个像素中斜线上的点
        vec2 pixelPoint = vec2(gl_LaunchIDEXT.xy) + vec2((i + 1.0f) / float(constant.sampleCount + 1));

        float r1 = rnd(seed);
        float r2 = rnd(seed);
        // 子像素抖动采样: 每次在像素中的不同位置发射光线，以达到抗锯齿的目的
        vec2 subpixel_jitter = constant.frame == 0 ? vec2(0.5f, 0.5f) : vec2(r1, r2);
        pixelPoint = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;

        // gl_LaunchSizeEXT 包含了当执行 vkCmdTraceRaysKHR 指令时指定的渲染图片维度
        // [0, 1] -> [-1, 1]
        vec2 uv = pixelPoint / gl_LaunchSizeEXT.xy;
        uv = uv * 2 - 1;

        // 光线方向
        vec3 viewDirection = normalize(inverse(camera.view) * vec4((inverse(camera.project) * vec4(uv, -1, 1)).xyz, 0)).xyz;

        // 用于指示所有的几何体都按照不透明物体对待
        uint rayFlags = gl_RayFlagsOpaqueEXT;

        /*
            通过调用 traceRayEXT 函数从相机发射光线
            1. 光线没有击中任何物体时，将会调用未命中着色器组中索引为0的未击中着色器(raytrace.miss)
            raytrace.miss 着色器将 prd.value 设置为 clearColor(背景色)
            2. 光线击中物体时，调用 raytrace.rchit 最近命中着色器
        */
        traceRayEXT(
            tlas,            // 顶层加速结构用于相交查询
            rayFlags,        // 控制光线追踪的位域
            0xff,            // cullMask
            0,               // sbtRecordOffset   sbtRecordOffset 和 sbtRecordStride 控制每一个实体的 hitGroupId
            0,               // sbtRecordStride   如何从底层加速结构命中组数组中获取命中组，这里只有一个命中组(raytrace.rchit)
            0,               // missIndex 表示底层加速结构的未命中着色器组的索引，当没有与任何实体相交时将会调用该索引对应的未命中着色器
            camera.position, // 光线的源点
            0.001,           // Tmin
            viewDirection,   // 光线的方向
            10000.0,         // Tmax
            0                // payload (location = 0) -> prd
        );

        value += prd.value;
    }
    
    // 将负载结果写入图片
    float a = 1.0f / float(constant.frame + 1);
    vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb;
    vec3 color = value / float(constant.sampleCount);
    int b = 0;
    if (b == 0) a = 1;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(oldColor, color, a), 1.0f));
}
